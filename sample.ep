%% Ctrl-Shift-P > sserl > Return

%% Structures
record h :-
  int X,
  char Y,
  string A. %% note the period

%% Structures with structures within them
record b :-
  int X,
  char Y,
  string Str,
  h H. %% note the period

record complex :-
  int Real,
  int Imaginary.

%% Union type (What do you think about the `either` keyword?)
either intchar :-
  int I,
  char C.

%% Functions for complex numbers
function complex(int X, int Y) -> complex :-
  %% How in sweet hell are we going to return struct types? is it even possible
  %% in the general case?
  complex C,
  C_Real      is X,
  C_Imaginary is Y,
  return C.

function sum(complex A, complex B) -> complex :-
  complex C,
  C_Real      is A_Real      + B_Real,
  C_Imaginary is A_Imaginary + B_Imaginary,
  return C.

function negate(complex A) -> complex :-
  complex C,
  C_Real      is -A_Real,
  C_Imaginary is -A_Imaginary,
  return C.

%% Other functions
function prod(complex A, complex B) -> complex :-
  complex C,
  C_Real      is (A_Real * B_Real)      - (A_Imaginary * B_Imaginary),
  C_Imaginary is (A_Real * B_Imaginary) + (A_Imaginary * B_Real),
  return C.

function power(int Base, int Exponent) -> int :-
  int Result,

  %% The operator `|`, as in `A|B` returns true if A divides B with
  %% remainder 0, while the operator `!|` returns the opposite value.

  %% Let it be noted that the last clause in an `if` block does NOT
  %% end with a `;`, since the end keyword closes the clause. Same
  %% comment applies to `for` and `while` blocks. (*)
  if
    Exponent  = 0 -> Result is 1;
    Exponent  = 1 -> Result is Base;
    2  | Exponent -> Result is power(Base * Base, Exponent/2);
    2 !| Exponent -> Result is Base * power(Base * Base, (Exponent - 1) / 2)
  end,

  return(Result).

function max(int A, int B) -> int :-
  %% How in hell are we going to make sure a function always returns (!?)
  if
    A =< B -> return B;
    A >  B -> return A
  end.

function min(int A, int B) -> int :-
  if
    A =< B -> return A;
    A >  B -> return B
  end.

function f(int X) -> int :-
  %% stuffs
  bool B is X < 10 and ((((True)))) and (True or (False) or (False and True)),
  
  if B ->
    print("True\n"),
    int X is 1 + 4 * (4 + 5), 
    int Z is -5;
    for I in {1..10} ->
      int XX is 4,
      int YY is 5,
      XX is XX+YY+Z
    end,
    return X.
  otherwise ->
    if not B ->
      print("False\n"),
      return 10;
    otherwise ->
      print("Algo muy malo ocurrio\n"),  
      int Y is X - X,
      Y is Y/Y,
      return -121827397
    end
  end,
  return X.

%% Procedimientos
procedure q(int X, int Y, int Z) :-
  if Z > 0 ->
    X is X + 10,
    Y is Z + Y,
    Z is Z - 1,
    q(Y,X,Z)
  end.

procedure main() :- 
  int X, read(X),
  int Y, read(Y),

  int Base is max(X, Y),
  int Exponent is min(X,Y),

  print(Base),
  print(Exponent),

  int Z is power(Base, Exponent),

  print(Z),

  while Z > 0 ->
    Z is Z / 2,
    print(Z)
  end,

  int$5 Warr,
  for I in {0..4} ->
    Warr$I is 0
  end,

  intchar K,
  if
    X > Y -> K_I is Y;
    otherwise -> K_C is 'C'
  end

  %% The following will be a runtime error if K_I was set.
  print(K_C),


  %% Given the comment in (*), the syntax kind of allows the following
  %% blocks as well:
  %% (Which I guess would just perform the actions in order.)
  for
    I in {0..5} -> something();
    I in {3..10} -> somethingElse()
  end,

  while
    Z > Y -> something3();
    Y > X -> something4();
    X > Z -> something5()
  end.
